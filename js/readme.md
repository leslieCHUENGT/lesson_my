# == 与 === 
- ==
  - 两个等于号==叫做等于操作符，如果**操作数**相等，则会返回true
  - 两个**操作数**都为简单类型，字符串和布尔值都会转换成数值，再比较
  - 简单类型与引用类型比较，对象**转化成**其原始类型的值，再比较
  - 两个**操作数**都为引用类型，则比较它们**是否指向同一个对象**
  - **null 和 undefined 相等**
  - 存在** NaN **则返回 **false**
- ===
  - 三个等于号===叫做全等操作符，只有两个操作数**在不转换的前提**下相等才返回true
  - 
所以，除了在比较对象属性为null或者undefined的情况下，我们可以使用相等操作符（==），其他情况建议一律使用全等操作符（===）

# 作用域
- 作用域 **指程序中定义变量的区域**，它**决定了**当前**执行代码**对**变量**的**访问权限**。
- JavaScript 的作用域分以下三种：
  - **全局作用域**：脚本模式运行所有代码的默认作用域
  - 模块作用域：模块模式中运行代码的作用域
  - **函数作用域**：由函数创建的作用域
  - 此外，用 let 或 const 声明的变量属于额外的作用域：
    - 块级作用域：用一对花括号（一个代码块）创建出来的作用域
- 当可执行代码内部**访问变量**时，会**先查找本地作用域**，如果找到目标变量即返回，**否则**会去**父级作用域继续查找**...一直找到**全局作用域**。我们把这种作用域的嵌套机制，称为 **作用域链**。

# 闭包
- 能够访问**其他函数内部变量的函数**，被称为 闭包。
简单来说，闭包就是**函数内部定义的函数**，**被返回了**出去并在**外部调用。**
## 应用场景
- 单例模式
  - 单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
- 在JavaScript中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法
- 柯里化函数，柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用

# JavaScript垃圾回收机制(CG)
- 垃圾回收机制是引擎来做的,V8 引擎发展至今对该机制的优化为例
- **没有了引用关系，也就是无用的对象**这个时候假如任由它搁置，一个两个还好，多了的话内存也会受不了，所以就需要被清理（回收）
- 程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃
- **可达性**就是那些**以某种方式可访问或者说可用的值**，它们**被保证存储在内存中**，反之**不可访问则需回收**
- 至于如何回收，其实就是怎样发现这些**不可达的对象（垃圾）**它并给予清理的问题， JavaScript 垃圾回收机制的原理说白了也就是**定期找出那些不再用到的内存（变量）**，然后**释放其内存**
## 算法策略
- 标记清除法
引擎在执行 GC（使用标记清除算法）时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组 根 对象，而所谓的根对象，其实在浏览器环境中包括又不止于 **全局Window对象**、**文档DOM树** 等

整个标记清除算法大致过程就像下面这样：
- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记
- 假设内存中所有对象都是垃圾，**全标记为0**
- 然后从各个根对象**开始遍历**，把**不是垃圾的节点改成1**
- **清理**所有标记为**0**的垃圾，**销毁并回收**它们所占用的**内存空间**
- 最后，把所有内存中**对象标记修改为0**，等待下一轮垃圾回收
- 优点
  - 标记清除算法的优点只有一个，那就是实现比较简单
- 缺点
  - 就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 **内存碎片**
  - 那如何找到合适的块呢？我们可以采取下面三种分配策略
    - Fist-fit
    - Best-fit
    - Worst-fit
  - 内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块
  - 分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢
- 引用计数算法
  - 它把 对象是否不再需要 简化定义为 **对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收**目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下












